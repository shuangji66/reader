#!/bin/bash
#---环境定义---
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8

#---运行文件定义---
LOG_FILE="${TRIM_DATA_SHARE_PATHS%%:*}/logs/info.log"
PID_FILE="${TRIM_PKGVAR}/app.pid"
READER_JAR="${TRIM_APPDEST}/reader.jar"

#---定义配置参数---
WORK_DIR="${TRIM_DATA_SHARE_PATHS%%:*}"   # 工作目录
SECURE_MODE="$secure_mode"                # 是否需要登录鉴权，开启后将支持多用户模式
INVITE_CODE="$invite_code"                # 注册邀请码，为空时则开放注册，否则注册时需要输入邀请码
SECURE_KEY="$secure_key"                  # 管理密码，开启鉴权时，前端管理用户空间的管理密码
CACHE_CHAPTER="$cache_chapter"            # 是否缓存章节内容
DEBUG_LOG="$debug_log"                    # 是否打开调试日志
AUTO_CLEAR="$auto_clear"                  # 是否自动清理不活跃用户，为0不清理，大于0为清理超过 autoClearInactiveUser 天未登录的用户
SHELF_UPDATE="$shelf_update"              # 书架自动更新间隔时间，单位分钟，必须是10的倍数10
USER_LIMIT="$user_limit"                   # 用户上限，最大 15
ENABLE_WEBDAV="$enable_webdav"            # 新用户是否默认启用webdav
ENABLE_LOCALSTORE="$enable_localstore"    # 新用户是否默认启用localStore
ENABLE_BOOKSOURCE="$enable_booksource"    # 新用户是否默认可编辑书源，如果为false，则只能使用默认书源，不能新增/修改/删除
ENABLE_RSSSOURCE="$enable_rss"            # 新用户是否默认可编辑RSS源false
BOOKSOURCE_LIMIT="$booksource_limit"      # 新用户默认书源上限100
BOOK_LIMIT="$book_limit"                  # 新用户默认书籍上限200
AUTO_BACKUP="$auto_backup"                # 是否自动备份用户数据false
PASSWORD_LENGTH="$password_length"        # 用户密码最小长度
BOOKSOURCE_UPDATE="$booksource_update"    # 远程书源定时更新间隔时间，单位分钟，必须是10的倍数720
UI_PORT="$ui_port"                        # webui监听端口
HTTP_HEADER="524288"                      # http-header最大的size

log_msg() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> ${LOG_FILE}
}

java_cmd() {
    # 检测选装包java-17-openj9（优先使用）
    if [ -x "/var/apps/java-17-openj9/target/bin/java" ]; then
        echo "/var/apps/java-17-openj9/target/bin/java"
        return
    fi
    # 检测选装包java-8-openj9
    if [ -x "/var/apps/java-8-openj9/target/bin/java" ]; then
        echo "/var/apps/java-8-openj9/target/bin/java"
        return
    fi  
    # 无选装包使用java-17-openjdk
    if [ -x "/var/apps/java-17-openjdk/target/bin/java" ]; then
        echo "/var/apps/java-17-openjdk/target/bin/java"
        return
    fi
}

start_process() {
    if status; then
        log_msg "Reader is already running"
        return 0
    fi

    JAVA_CMD=$(java_cmd)
    #---构建启动参数---
    if [ "${SECURE_MODE}" = "true" ]; then
        # 多用户模式
        JAVA_OPTS="-Xms256m -Xmx1024m"
        # 注册邀请码，为空时则开放注册，否则注册时需要输入邀请码
        if [[ -n "$INVITE_CODE" ]]; then
            JAVA_OPTS="${JAVA_OPTS} -Dreader.app.inviteCode=${INVITE_CODE}"
        fi
        # 管理密码，开启鉴权时，前端管理用户空间的管理密码
        JAVA_OPTS="${JAVA_OPTS} -Dreader.app.secureKey=${SECURE_KEY}"
        # 是否自动清理不活跃用户，为0不清理，大于0为清理超过 autoClearInactiveUser 天未登录的用户
        JAVA_OPTS="${JAVA_OPTS} -Dreader.app.autoClearInactiveUser=${AUTO_CLEAR}"
        # 用户上限，最大 15
        JAVA_OPTS="${JAVA_OPTS} -Dreader.app.userLimit=${USER_LIMIT}"
        # 新用户是否默认启用webdav
        JAVA_OPTS="${JAVA_OPTS} -Dreader.app.defaultUserEnableWebdav=${ENABLE_WEBDAV}"
        # 新用户是否默认启用localStore
        JAVA_OPTS="${JAVA_OPTS} -Dreader.app.defaultUserEnableLocalStore=${ENABLE_LOCALSTORE}"
        # 新用户是否默认可编辑书源，如果为false，则只能使用默认书源，不能新增/修改/删除
        JAVA_OPTS="${JAVA_OPTS} -Dreader.app.defaultUserEnableBookSource=${ENABLE_BOOKSOURCE}"
        # 新用户是否默认可编辑RSS源false
        JAVA_OPTS="${JAVA_OPTS} -Dreader.app.defaultUserEnableRssSource=${ENABLE_RSSSOURCE}"
        # 新用户默认书源上限100
        JAVA_OPTS="${JAVA_OPTS} -Dreader.app.defaultUserBookSourceLimit=${BOOKSOURCE_LIMIT}"
        # 新用户默认书籍上限200
        JAVA_OPTS="${JAVA_OPTS} -Dreader.app.defaultUserBookLimit=${BOOK_LIMIT}"
        # 用户密码最小长度
        JAVA_OPTS="${JAVA_OPTS} -Dreader.app.minUserPasswordLength=${PASSWORD_LENGTH}"
    else
        # 单用户模式
        JAVA_OPTS="-Xms128m -Xmx256m"
    fi
    # 设置字符编码，解决中文文件名问题
    JAVA_OPTS="${JAVA_OPTS} -Dfile.encoding=UTF-8"
    JAVA_OPTS="${JAVA_OPTS} -Dsun.jnu.encoding=UTF-8"
    JAVA_OPTS="${JAVA_OPTS} -Dsun.stdout.encoding=UTF-8"
    JAVA_OPTS="${JAVA_OPTS} -Dsun.stderr.encoding=UTF-8"
    # 修改cache目录，可与社区版reader共存
    JAVA_OPTS="${JAVA_OPTS} -Dvertx.cacheDirBase=${TRIM_PKGVAR}"
    # 工作目录
    JAVA_OPTS="${JAVA_OPTS} -Dreader.app.workDir=${WORK_DIR}"
    # 是否需要登录鉴权，开启后将支持多用户模式
    JAVA_OPTS="${JAVA_OPTS} -Dreader.app.secure=${SECURE_MODE}"
    # 是否缓存章节内容
    JAVA_OPTS="${JAVA_OPTS} -Dreader.app.cacheChapterContent=${CACHE_CHAPTER}"
    # 是否打开调试日志
    JAVA_OPTS="${JAVA_OPTS} -Dreader.app.debugLog=${DEBUG_LOG}"
    # 书架自动更新间隔时间，单位分钟，必须是10的倍数10
    JAVA_OPTS="${JAVA_OPTS} -Dreader.app.shelfUpdateInteval=${SHELF_UPDATE}"
    # 是否自动备份用户数据false
    JAVA_OPTS="${JAVA_OPTS} -Dreader.app.autoBackupUserData=${AUTO_BACKUP}"
    # 远程书源定时更新间隔时间，单位分钟，必须是10的倍数720
    JAVA_OPTS="${JAVA_OPTS} -Dreader.app.remoteBookSourceUpdateInterval=${BOOKSOURCE_UPDATE}"
    # webui监听端口
    JAVA_OPTS="${JAVA_OPTS} -Dreader.server.port=${UI_PORT}"
    # http-header最大的size
    JAVA_OPTS="${JAVA_OPTS} -Dreader.server.max-http-header-size=${HTTP_HEADER}"
    # 禁用 JMX 以避免 cgroup v2 兼容性问题
    JAVA_OPTS="${JAVA_OPTS} -Dspring.jmx.enabled=false"

    # 启动命令
    CMD="${JAVA_CMD} ${JAVA_OPTS} -jar ${READER_JAR}"

    log_msg "Java: ${JAVA_CMD}"
    log_msg "Command: ${CMD}"

    # 启动Reader进程
    cd ${TRIM_APPDEST}
    nohup ${CMD} 2>&1 &
    
    # 写入PID
    printf "%s" "$!" > ${PID_FILE}
    log_msg "Reader started with PID: $!"
    
    # 等待启动
    sleep 3
    
    if status; then
        log_msg "Reader started successfully"
        return 0
    else
        log_msg "Reader failed to start"
        return 1
    fi
}

stop_process() {
    log_msg "Stopping Reader process..."

    local pid=""
    
    # 从PID文件获取PID
    if [ -r "${PID_FILE}" ]; then
        pid=$(head -n 1 "${PID_FILE}" | tr -d '[:space:]')
        log_msg "PID from file: ${pid}"
        
        if ! check_process "${pid}"; then
            rm -f "${PID_FILE}"
            pid=""
        fi
    fi
    
    # 如果PID文件方法失败，搜索进程
    if [ -z "${pid}" ]; then
        pid=$(ps aux | grep -v grep | grep "reader.jar" | grep "${TRIM_APPDEST}" | awk '{print $2}' | head -n 1)
        
        if [ -z "${pid}" ]; then
            log_msg "Process not found"
            rm -f "${PID_FILE}"
            return 0
        fi
        log_msg "Found PID from ps: ${pid}"
    fi

    # 发送TERM信号
    log_msg "Sending TERM signal to PID: ${pid}"
    kill -TERM ${pid} >> ${LOG_FILE} 2>&1

    # 等待进程退出
    local count=0
    while check_process "${pid}" && [ $count -lt 15 ]; do
        sleep 1
        count=$((count + 1))
        log_msg "Waiting for process to terminate... (${count}s/15s)"
    done

    # 如果还在运行，强制杀死
    if check_process "${pid}"; then
        log_msg "Sending KILL signal to PID: ${pid}"
        kill -KILL "${pid}" >> ${LOG_FILE} 2>&1
        sleep 1
    fi
    
    rm -f "${PID_FILE}"
    log_msg "Reader stopped"
    return 0
}

check_process() {
    local pid=$1
    if [ -n "${pid}" ] && kill -0 "${pid}" 2>/dev/null; then
        return 0
    else
        return 1
    fi
}

status() {
    # 检查PID文件
    if [ -f "${PID_FILE}" ]; then
        local pid=$(head -n 1 "${PID_FILE}" | tr -d '[:space:]')
        if check_process "${pid}"; then
            # 验证是否是Reader进程
            if ps aux | grep -v grep | grep "reader.*\.jar" | awk '{print $2}' | grep -q "^${pid}$"; then
                return 0
            fi
        fi
        rm -f "${PID_FILE}"
    fi

    # 回退：搜索进程
    local pid=$(ps aux | grep -v grep | grep "reader.*\.jar" | grep "${TRIM_APPDEST}" | awk '{print $2}' | head -n 1)
    if [ -n "${pid}" ]; then
        printf "%s" "${pid}" > ${PID_FILE}
        log_msg "Found running process PID=${pid}, repaired PID_FILE"
        return 0
    fi
    
    return 1
}

case $1 in
start)
    start_process
    ;;
stop)
    stop_process
    ;;
status)
    if status; then 
        exit 0
    else 
        exit 3
    fi
    ;;
*)
    exit 1
    ;;
esac
